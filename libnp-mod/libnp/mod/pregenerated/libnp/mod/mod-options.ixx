// -*- C++ -*-
//
// This file was generated by CLI, a command line interface
// compiler for C++.
//

// Begin prologue.
//
//
// End prologue.

#include <cassert>

namespace np
{
  namespace mod
  {
    namespace cli
    {
      // usage_para
      //
      inline usage_para::
      usage_para (value v)
      : v_ (v)
      {
      }

      // unknown_mode
      //
      inline unknown_mode::
      unknown_mode (value v)
      : v_ (v)
      {
      }

      // exception
      //
      inline ::std::ostream&
      operator<< (::std::ostream& os, const exception& e)
      {
        e.print (os);
        return os;
      }

      // unknown_option
      //
      inline unknown_option::
      unknown_option (const std::string& option)
      : option_ (option)
      {
      }

      inline const std::string& unknown_option::
      option () const
      {
        return option_;
      }

      // unknown_argument
      //
      inline unknown_argument::
      unknown_argument (const std::string& argument)
      : argument_ (argument)
      {
      }

      inline const std::string& unknown_argument::
      argument () const
      {
        return argument_;
      }

      // missing_value
      //
      inline missing_value::
      missing_value (const std::string& option)
      : option_ (option)
      {
      }

      inline const std::string& missing_value::
      option () const
      {
        return option_;
      }

      // invalid_value
      //
      inline invalid_value::
      invalid_value (const std::string& option,
                     const std::string& value,
                     const std::string& message)
      : option_ (option),
        value_ (value),
        message_ (message)
      {
      }

      inline const std::string& invalid_value::
      option () const
      {
        return option_;
      }

      inline const std::string& invalid_value::
      value () const
      {
        return value_;
      }

      inline const std::string& invalid_value::
      message () const
      {
        return message_;
      }

      // file_io_failure
      //
      inline file_io_failure::
      file_io_failure (const std::string& file)
      : file_ (file)
      {
      }

      inline const std::string& file_io_failure::
      file () const
      {
        return file_;
      }

      // unmatched_quote
      //
      inline unmatched_quote::
      unmatched_quote (const std::string& argument)
      : argument_ (argument)
      {
      }

      inline const std::string& unmatched_quote::
      argument () const
      {
        return argument_;
      }

      // argv_scanner
      //
      inline argv_scanner::
      argv_scanner (int& argc,
                    char** argv,
                    bool erase,
                    std::size_t sp)
      : start_position_ (sp + 1),
        i_ (1),
        argc_ (argc),
        argv_ (argv),
        erase_ (erase)
      {
      }

      inline argv_scanner::
      argv_scanner (int start,
                    int& argc,
                    char** argv,
                    bool erase,
                    std::size_t sp)
      : start_position_ (sp + static_cast<std::size_t> (start)),
        i_ (start),
        argc_ (argc),
        argv_ (argv),
        erase_ (erase)
      {
      }

      inline int argv_scanner::
      end () const
      {
        return i_;
      }

      // argv_file_scanner
      //
      inline argv_file_scanner::
      argv_file_scanner (int& argc,
                         char** argv,
                         const std::string& option,
                         bool erase,
                         std::size_t sp)
      : argv_scanner (argc, argv, erase, sp),
        option_ (option),
        options_ (&option_info_),
        options_count_ (1),
        i_ (1),
        skip_ (false)
      {
        option_info_.option = option_.c_str ();
        option_info_.search_func = 0;
      }

      inline argv_file_scanner::
      argv_file_scanner (int start,
                         int& argc,
                         char** argv,
                         const std::string& option,
                         bool erase,
                         std::size_t sp)
      : argv_scanner (start, argc, argv, erase, sp),
        option_ (option),
        options_ (&option_info_),
        options_count_ (1),
        i_ (1),
        skip_ (false)
      {
        option_info_.option = option_.c_str ();
        option_info_.search_func = 0;
      }

      inline argv_file_scanner::
      argv_file_scanner (const std::string& file,
                         const std::string& option,
                         std::size_t sp)
      : argv_scanner (0, zero_argc_, 0, sp),
        option_ (option),
        options_ (&option_info_),
        options_count_ (1),
        i_ (1),
        skip_ (false)
      {
        option_info_.option = option_.c_str ();
        option_info_.search_func = 0;

        load (file);
      }

      inline argv_file_scanner::
      argv_file_scanner (int& argc,
                         char** argv,
                         const option_info* options,
                         std::size_t options_count,
                         bool erase,
                         std::size_t sp)
      : argv_scanner (argc, argv, erase, sp),
        options_ (options),
        options_count_ (options_count),
        i_ (1),
        skip_ (false)
      {
      }

      inline argv_file_scanner::
      argv_file_scanner (int start,
                         int& argc,
                         char** argv,
                         const option_info* options,
                         std::size_t options_count,
                         bool erase,
                         std::size_t sp)
      : argv_scanner (start, argc, argv, erase, sp),
        options_ (options),
        options_count_ (options_count),
        i_ (1),
        skip_ (false)
      {
      }

      inline argv_file_scanner::
      argv_file_scanner (const std::string& file,
                         const option_info* options,
                         std::size_t options_count,
                         std::size_t sp)
      : argv_scanner (0, zero_argc_, 0, sp),
        options_ (options),
        options_count_ (options_count),
        i_ (1),
        skip_ (false)
      {
        load (file);
      }

      inline const std::string& option::
      name () const
      {
        return name_;
      }

      inline const option_names& option::
      aliases () const
      {
        return aliases_;
      }

      inline bool option::
      flag () const
      {
        return flag_;
      }

      inline const std::string& option::
      default_value () const
      {
        return default_value_;
      }

      inline option::
      option ()
      {
      }

      inline option::
      option (const std::string& n,
              const option_names& a,
              bool f,
              const std::string& dv)
      : name_ (n), aliases_ (a), flag_ (f), default_value_ (dv)
      {
      }

      inline options::container_type::const_iterator options::
      find (const std::string& name) const
      {
        map_type::const_iterator i (map_.find (name));
        return i != map_.end () ? begin () + i->second : end ();
      }
    }
  }
}

namespace np
{
  namespace options
  {
    // database
    //

    inline const std::string& database::
    np_db_user () const
    {
      return this->np_db_user_;
    }

    inline std::string& database::
    np_db_user ()
    {
      return this->np_db_user_;
    }

    inline void database::
    np_db_user (const std::string& x)
    {
      this->np_db_user_ = x;
    }

    inline bool database::
    np_db_user_specified () const
    {
      return this->np_db_user_specified_;
    }

    inline void database::
    np_db_user_specified (bool x)
    {
      this->np_db_user_specified_ = x;
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.
